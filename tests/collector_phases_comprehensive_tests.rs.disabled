use fugrip::collector_phases::*;
use fugrip::*;
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

// Tests for ThreadRegistration
#[cfg(test)]
mod thread_registration_tests {
    use super::*;

    #[test]
    fn test_thread_registration_creation() {
        let registration = ThreadRegistration {
            thread_id: thread::current().id(),
            stack_base: 0x7fff00000000,
            stack_bounds: (0x7fff00000000, 0x7fff00010000),
            last_known_sp: AtomicUsize::new(0x7fff00008000),
            local_roots: Vec::new(),
            is_active: AtomicBool::new(true),
        };

        assert_eq!(registration.thread_id, thread::current().id());
        assert_eq!(registration.stack_base, 0x7fff00000000);
        assert_eq!(registration.stack_bounds.0, 0x7fff00000000);
        assert_eq!(registration.stack_bounds.1, 0x7fff00010000);
        assert_eq!(registration.last_known_sp.load(Ordering::Acquire), 0x7fff00008000);
        assert_eq!(registration.local_roots.len(), 0);
        assert!(registration.is_active.load(Ordering::Acquire));
    }

    #[test]
    fn test_thread_registration_state_changes() {
        let registration = ThreadRegistration {
            thread_id: thread::current().id(),
            stack_base: 0x1000000,
            stack_bounds: (0x1000000, 0x1100000),
            last_known_sp: AtomicUsize::new(0x1050000),
            local_roots: Vec::new(),
            is_active: AtomicBool::new(true),
        };

        // Test changing stack pointer
        registration.last_known_sp.store(0x1060000, Ordering::Release);
        assert_eq!(registration.last_known_sp.load(Ordering::Acquire), 0x1060000);

        // Test deactivating
        registration.is_active.store(false, Ordering::Release);
        assert!(!registration.is_active.load(Ordering::Acquire));
    }
}

// Tests for CollectorState
#[cfg(test)]
mod collector_state_tests {
    use super::*;

    #[test]
    fn test_collector_state_creation() {
        let collector = CollectorState::new();
        
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Waiting as usize);
        assert!(!collector.marking_active.load(Ordering::Acquire));
        assert!(!collector.allocation_color.load(Ordering::Acquire));
        assert_eq!(collector.worker_count.load(Ordering::Acquire), 0);
        assert_eq!(collector.workers_finished.load(Ordering::Acquire), 0);
        assert!(!collector.handshake_requested.load(Ordering::Acquire));
        assert_eq!(collector.active_mutator_count.load(Ordering::Acquire), 0);
        assert_eq!(collector.handshake_acknowledgments.load(Ordering::Acquire), 0);
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 0);
        assert!(!collector.suspension_requested.load(Ordering::Acquire));
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 0);
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 0);
    }

    #[test]
    fn test_collector_state_phase_management() {
        let collector = CollectorState::new();
        
        // Test initial state
        assert!(!collector.is_marking());
        
        // Test phase transitions
        collector.set_phase(CollectorPhase::Marking);
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Marking as usize);
        
        collector.set_phase(CollectorPhase::Sweeping);
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Sweeping as usize);
        
        collector.set_phase(CollectorPhase::Waiting);
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Waiting as usize);
    }

    #[test]
    fn test_collector_state_request_collection() {
        let collector = CollectorState::new();
        
        // Initially in waiting state
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Waiting as usize);
        
        // Request collection should transition to marking
        collector.request_collection();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Marking as usize);
        
        // Second request should not change state when not waiting
        collector.request_collection();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Marking as usize);
    }

    #[test]
    fn test_mutator_thread_management() {
        let collector = CollectorState::new();
        
        assert_eq!(collector.get_active_mutator_count(), 0);
        
        collector.register_mutator_thread();
        assert_eq!(collector.get_active_mutator_count(), 1);
        
        collector.register_mutator_thread();
        assert_eq!(collector.get_active_mutator_count(), 2);
        
        collector.unregister_mutator_thread();
        assert_eq!(collector.get_active_mutator_count(), 1);
        
        collector.unregister_mutator_thread();
        assert_eq!(collector.get_active_mutator_count(), 0);
    }

    #[test]
    fn test_worker_thread_management() {
        let collector = CollectorState::new();
        
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 0);
        
        collector.register_worker_thread();
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 1);
        
        collector.register_worker_thread();
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 2);
        
        collector.unregister_worker_thread();
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 1);
        
        collector.unregister_worker_thread();
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 0);
    }

    #[test]
    fn test_handshake_mechanism() {
        let collector = CollectorState::new();
        
        // Initially no handshake requested
        assert!(!collector.is_handshake_requested());
        assert_eq!(collector.handshake_acknowledgments.load(Ordering::Acquire), 0);
        
        // Register a mutator
        collector.register_mutator_thread();
        assert_eq!(collector.get_active_mutator_count(), 1);
        
        // Start handshake in a separate thread (since request_handshake waits)
        let collector_clone = Arc::new(collector);
        let collector_for_thread = collector_clone.clone();
        
        let handle = thread::spawn(move || {
            collector_for_thread.request_handshake();
        });
        
        // Give the handshake time to start
        thread::sleep(Duration::from_millis(10));
        
        // Should be requesting handshake
        assert!(collector_clone.is_handshake_requested());
        
        // Acknowledge the handshake
        collector_clone.acknowledge_handshake();
        
        // Wait for the handshake to complete
        handle.join().unwrap();
        
        // Should no longer be requesting
        assert!(!collector_clone.is_handshake_requested());
    }

    #[test]
    fn test_suspension_mechanism() {
        let collector = CollectorState::new();
        
        assert!(!collector.is_suspension_requested());
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 0);
        
        // Test suspend for fork
        collector.suspend_for_fork();
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 1);
        assert!(collector.is_suspension_requested());
        
        // Test nested suspend
        collector.suspend_for_fork();
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 2);
        
        // Test resume
        collector.resume_after_fork();
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 1);
        assert!(collector.is_suspension_requested()); // Still suspended
        
        collector.resume_after_fork();
        assert_eq!(collector.suspend_count.load(Ordering::Acquire), 0);
        assert!(!collector.is_suspension_requested()); // Now resumed
    }

    #[test]
    fn test_worker_suspension_acknowledgment() {
        let collector = CollectorState::new();
        
        // Register workers
        collector.register_worker_thread();
        collector.register_worker_thread();
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 2);
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 0);
        
        // First worker acknowledges suspension
        collector.worker_acknowledge_suspension();
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 1);
        
        // Second worker acknowledges suspension
        collector.worker_acknowledge_suspension();
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 2);
        
        // Resume workers
        collector.worker_acknowledge_resumption();
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 1);
        
        collector.worker_acknowledge_resumption();
        assert_eq!(collector.suspended_worker_count.load(Ordering::Acquire), 0);
    }

    #[test]
    fn test_marking_work_steal_and_donate() {
        let collector = CollectorState::new();
        
        // Initially no work
        assert!(collector.steal_marking_work().is_none());
        
        // Add some work to the global stack
        {
            let mut stack = collector.global_mark_stack.lock().unwrap();
            for i in 0..100 {
                let ptr = (0x1000 + i * 8) as *mut GcHeader<()>;
                stack.push(unsafe { SendPtr::new(ptr) });
            }
        }
        
        // Steal work
        let stolen_work = collector.steal_marking_work();
        assert!(stolen_work.is_some());
        
        let work = stolen_work.unwrap();
        assert!(work.len() > 0);
        assert!(work.len() <= 32); // Should not steal more than batch size
        
        // Test work donation
        let mut local_stack = Vec::new();
        for i in 0..200 {
            let ptr = (0x2000 + i * 8) as *mut GcHeader<()>;
            local_stack.push(unsafe { SendPtr::new(ptr) });
        }
        
        let original_len = local_stack.len();
        collector.donate_marking_work(&mut local_stack);
        
        // Should have donated some work
        assert!(local_stack.len() < original_len);
    }

    #[test]
    fn test_thread_registration_and_unregistration() {
        let collector = CollectorState::new();
        
        // Initially no threads registered
        assert_eq!(collector.registered_threads.lock().unwrap().len(), 0);
        
        // Register current thread
        let result = collector.register_thread_for_gc((0x1000000, 0x1100000));
        assert!(result.is_ok());
        assert_eq!(collector.registered_threads.lock().unwrap().len(), 1);
        
        // Try to register same thread again (should fail)
        let result2 = collector.register_thread_for_gc((0x1000000, 0x1100000));
        assert!(result2.is_err());
        assert_eq!(collector.registered_threads.lock().unwrap().len(), 1);
        
        // Update stack pointer
        collector.update_thread_stack_pointer();
        
        // Unregister thread
        collector.unregister_thread_from_gc();
        assert_eq!(collector.registered_threads.lock().unwrap().len(), 0);
    }

    #[test]
    fn test_stack_bounds_detection() {
        let collector = CollectorState::new();
        
        // Test getting current thread stack bounds
        let (bottom, top) = collector.get_current_thread_stack_bounds();
        
        // On supported platforms, should get valid bounds
        #[cfg(any(target_os = "linux", target_os = "macos"))]
        {
            // Stack bounds should be non-zero and top should be greater than bottom
            if top != 0 && bottom != 0 {
                assert!(top > bottom);
                // Stack size should be reasonable (at least 1KB, at most 32MB)
                let stack_size = top - bottom;
                assert!(stack_size >= 1024);
                assert!(stack_size <= 32 * 1024 * 1024);
            }
        }
        
        // On unsupported platforms, might return (0, 0)
        #[cfg(not(any(target_os = "linux", target_os = "macos")))]
        {
            // Just ensure it doesn't panic
            let _ = (bottom, top);
        }
    }

    #[test]
    fn test_gc_phases() {
        let collector = CollectorState::new();
        
        // Test census phase
        collector.census_phase();
        
        // Test reviving phase  
        collector.reviving_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Reviving as usize);
        
        // Test remarking phase
        collector.remarking_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Remarking as usize);
        
        // Test sweeping phase
        collector.sweeping_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Sweeping as usize);
    }

    #[test]
    fn test_collector_state_misc_functionality() {
        let collector = CollectorState::new();
        
        // Test worker count access
        assert_eq!(collector.active_worker_count.load(Ordering::Acquire), 0);
        
        // Test thread safety operations
        assert!(!collector.is_marking());
        collector.set_phase(CollectorPhase::Marking);
        assert!(collector.is_marking());
        
        // Test phase queries
        collector.set_phase(CollectorPhase::Sweeping);
        assert!(!collector.is_marking());
    }

    #[test]
    fn test_gc_safe_fork_function() {
        // This test mainly verifies the function exists and can be called
        // Actually forking in a test would be complex and potentially problematic
        
        // For now, just test that the function compiles and exists
        let _func = gc_safe_fork;
        
        // In a real scenario, we might mock the fork call or test in a controlled environment
        // but for coverage purposes, testing the function signature is sufficient
    }
}

// Tests for MutatorState
#[cfg(test)]
mod mutator_state_tests {
    use super::*;

    #[test]
    fn test_mutator_state_creation() {
        let mutator = MutatorState::new();
        
        assert_eq!(mutator.local_mark_stack.len(), 0);
        assert!(!mutator.is_in_handshake);
        assert!(!mutator.allocating_black);
    }

    #[test]
    fn test_mutator_state_default() {
        let mutator = MutatorState::default();
        
        assert_eq!(mutator.local_mark_stack.len(), 0);
        assert!(!mutator.is_in_handshake);
        assert!(!mutator.allocating_black);
    }

    #[test]
    fn test_try_allocate_no_buffer() {
        let mut mutator = MutatorState::new();
        
        // Should return None when no buffer is allocated
        let result: Option<*mut GcHeader<i32>> = mutator.try_allocate();
        assert!(result.is_none());
    }

    #[test]
    fn test_check_handshake() {
        let collector = CollectorState::new();
        let mut mutator = MutatorState::new();
        
        // Initially not in handshake
        assert!(!mutator.is_in_handshake);
        assert!(!mutator.allocating_black);
        
        // No handshake requested - should not change state
        mutator.check_handshake(&collector);
        assert!(!mutator.is_in_handshake);
        assert!(!mutator.allocating_black);
        
        // Request handshake
        collector.handshake_requested.store(true, Ordering::Release);
        collector.allocation_color.store(true, Ordering::Release);
        
        // Now should participate in handshake
        mutator.check_handshake(&collector);
        assert!(!mutator.is_in_handshake); // Should be false after completing handshake
        assert!(mutator.allocating_black); // Should have switched allocation color
    }

    #[test]
    fn test_mutator_state_thread_local() {
        // Test that we can access the thread-local mutator state
        MUTATOR_STATE.with(|state| {
            let mut state = state.borrow_mut();
            assert_eq!(state.local_mark_stack.len(), 0);
            
            // Add something to the local mark stack
            let ptr = 0x1000 as *mut GcHeader<()>;
            state.local_mark_stack.push(unsafe { SendPtr::new(ptr) });
            assert_eq!(state.local_mark_stack.len(), 1);
        });
        
        // Verify it persists in the same thread
        MUTATOR_STATE.with(|state| {
            let state = state.borrow();
            assert_eq!(state.local_mark_stack.len(), 1);
        });
    }
}

#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_collector_and_mutator_interaction() {
        let collector = CollectorState::new();
        let mut mutator = MutatorState::new();
        
        // Register mutator
        collector.register_mutator_thread();
        
        // Test handshake coordination
        collector.handshake_requested.store(true, Ordering::Release);
        collector.allocation_color.store(true, Ordering::Release);
        
        // Mutator participates in handshake
        mutator.check_handshake(&collector);
        
        // Should have switched to black allocation
        assert!(mutator.allocating_black);
        
        // Acknowledge handshake
        collector.acknowledge_handshake();
        
        // Cleanup
        collector.unregister_mutator_thread();
    }

    #[test]
    fn test_multiple_phase_transitions() {
        let collector = CollectorState::new();
        
        // Full GC cycle simulation
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Waiting as usize);
        
        collector.request_collection();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Marking as usize);
        
        collector.set_phase(CollectorPhase::Censusing);
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Censusing as usize);
        
        collector.census_phase();
        
        collector.reviving_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Reviving as usize);
        
        collector.remarking_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Remarking as usize);
        
        collector.sweeping_phase();
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Sweeping as usize);
        
        collector.set_phase(CollectorPhase::Waiting);
        assert_eq!(collector.phase.load(Ordering::Acquire), CollectorPhase::Waiting as usize);
    }
}